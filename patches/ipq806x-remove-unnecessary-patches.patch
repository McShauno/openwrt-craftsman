From d8d668f02fa6e094029d93218191536d754c5f13 Mon Sep 17 00:00:00 2001
From: Pavel Kubelun <be.dissent@gmail.com>
Date: Fri, 5 Jan 2018 10:40:03 -0500
Subject: [PATCH] ipq806x: remove irrelevant patches

These patches are not needed for ipq806x.

Also remove the patch that adds L2 cache scaling support because it
is incomplete and a proper l2 scaling logic will be added by next
commit.

Signed-off-by: Pavel Kubelun <be.dissent@gmail.com>
---
 ...Support-adjusting-OPP-voltages-at-runtime.patch | 147 ---------------------
 ...otifiers-to-call-dev_pm_opp_get_-voltage-.patch | 107 ---------------
 ...a-helper-to-get-an-opp-regulator-for-devi.patch |  52 --------
 ...te-the-voltage-tolerance-when-adjusting-t.patch |  38 ------
 ...ufreq-dt-Handle-OPP-voltage-adjust-events.patch | 144 --------------------
 ...ufreq-dt-Add-L2-frequency-scaling-support.patch |  90 -------------
 .../0056-cpufreq-dt-Add-missing-rcu-locks.patch    |  23 ----
 7 files changed, 601 deletions(-)
 delete mode 100644 target/linux/ipq806x/patches-4.9/0049-PM-OPP-Support-adjusting-OPP-voltages-at-runtime.patch
 delete mode 100644 target/linux/ipq806x/patches-4.9/0050-OPP-Allow-notifiers-to-call-dev_pm_opp_get_-voltage-.patch
 delete mode 100644 target/linux/ipq806x/patches-4.9/0051-PM-OPP-Add-a-helper-to-get-an-opp-regulator-for-devi.patch
 delete mode 100644 target/linux/ipq806x/patches-4.9/0052-PM-OPP-Update-the-voltage-tolerance-when-adjusting-t.patch
 delete mode 100644 target/linux/ipq806x/patches-4.9/0054-cpufreq-dt-Handle-OPP-voltage-adjust-events.patch
 delete mode 100644 target/linux/ipq806x/patches-4.9/0055-cpufreq-dt-Add-L2-frequency-scaling-support.patch
 delete mode 100644 target/linux/ipq806x/patches-4.9/0056-cpufreq-dt-Add-missing-rcu-locks.patch

diff --git a/target/linux/ipq806x/patches-4.9/0049-PM-OPP-Support-adjusting-OPP-voltages-at-runtime.patch b/target/linux/ipq806x/patches-4.9/0049-PM-OPP-Support-adjusting-OPP-voltages-at-runtime.patch
deleted file mode 100644
index e2a4eede826..00000000000
--- a/target/linux/ipq806x/patches-4.9/0049-PM-OPP-Support-adjusting-OPP-voltages-at-runtime.patch
+++ /dev/null
@@ -1,147 +0,0 @@
-From c949f08cf20fe82971fbdb4015daa38210da492e Mon Sep 17 00:00:00 2001
-From: Stephen Boyd <sboyd@codeaurora.org>
-Date: Fri, 18 Sep 2015 17:52:06 -0700
-Subject: [PATCH 49/69] PM / OPP: Support adjusting OPP voltages at runtime
-
-On some SoCs the Adaptive Voltage Scaling (AVS) technique is
-employed to optimize the operating voltage of a device. At a
-given frequency, the hardware monitors dynamic factors and either
-makes a suggestion for how much to adjust a voltage for the
-current frequency, or it automatically adjusts the voltage
-without software intervention. Add an API to the OPP library for
-the former case, so that AVS type devices can update the voltages
-for an OPP when the hardware determines the voltage should
-change. The assumption is that drivers like CPUfreq or devfreq
-will register for the OPP notifiers and adjust the voltage
-according to suggestions that AVS makes.
-
-Cc: Nishanth Menon <nm@ti.com>
-Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
-Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
-Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
-Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
----
- drivers/base/power/opp/core.c | 77 +++++++++++++++++++++++++++++++++++++++++++
- include/linux/pm_opp.h        | 11 +++++++
- 2 files changed, 88 insertions(+)
-
---- a/drivers/base/power/opp/core.c
-+++ b/drivers/base/power/opp/core.c
-@@ -1521,6 +1521,83 @@ unlock:
- }
- 
- /**
-+ * dev_pm_opp_adjust_voltage() - helper to change the voltage of an OPP
-+ * @dev:		device for which we do this operation
-+ * @freq:		OPP frequency to adjust voltage of
-+ * @u_volt:		new OPP voltage
-+ *
-+ * Change the voltage of an OPP with an RCU operation.
-+ *
-+ * Return: -EINVAL for bad pointers, -ENOMEM if no memory available for the
-+ * copy operation, returns 0 if no modifcation was done OR modification was
-+ * successful.
-+ *
-+ * Locking: The internal device_opp and opp structures are RCU protected.
-+ * Hence this function internally uses RCU updater strategy with mutex locks to
-+ * keep the integrity of the internal data structures. Callers should ensure
-+ * that this function is *NOT* called under RCU protection or in contexts where
-+ * mutex locking or synchronize_rcu() blocking calls cannot be used.
-+ */
-+int dev_pm_opp_adjust_voltage(struct device *dev, unsigned long freq,
-+			      unsigned long u_volt)
-+{
-+	struct opp_table *opp_table;
-+	struct dev_pm_opp *new_opp, *tmp_opp, *opp = ERR_PTR(-ENODEV);
-+	int r = 0;
-+
-+	/* keep the node allocated */
-+	new_opp = kmalloc(sizeof(*new_opp), GFP_KERNEL);
-+	if (!new_opp)
-+		return -ENOMEM;
-+
-+	mutex_lock(&opp_table_lock);
-+
-+	/* Find the opp_table */
-+	opp_table = _find_opp_table(dev);
-+	if (IS_ERR(opp_table)) {
-+		r = PTR_ERR(opp_table);
-+		dev_warn(dev, "%s: Device OPP not found (%d)\n", __func__, r);
-+		goto unlock;
-+	}
-+
-+	/* Do we have the frequency? */
-+	list_for_each_entry(tmp_opp, &opp_table->opp_list, node) {
-+		if (tmp_opp->rate == freq) {
-+			opp = tmp_opp;
-+			break;
-+		}
-+	}
-+	if (IS_ERR(opp)) {
-+		r = PTR_ERR(opp);
-+		goto unlock;
-+	}
-+
-+	/* Is update really needed? */
-+	if (opp->u_volt == u_volt)
-+		goto unlock;
-+	/* copy the old data over */
-+	*new_opp = *opp;
-+
-+	/* plug in new node */
-+	new_opp->u_volt = u_volt;
-+
-+	list_replace_rcu(&opp->node, &new_opp->node);
-+	mutex_unlock(&opp_table_lock);
-+	call_srcu(&opp_table->srcu_head.srcu, &opp->rcu_head, _kfree_opp_rcu);
-+
-+	/* Notify the change of the OPP */
-+	srcu_notifier_call_chain(&opp_table->srcu_head, OPP_EVENT_ADJUST_VOLTAGE,
-+				 new_opp);
-+
-+	return 0;
-+
-+unlock:
-+	mutex_unlock(&opp_table_lock);
-+	kfree(new_opp);
-+	return r;
-+}
-+
-+/**
-  * dev_pm_opp_enable() - Enable a specific OPP
-  * @dev:	device for which we do this operation
-  * @freq:	OPP frequency to enable
---- a/include/linux/pm_opp.h
-+++ b/include/linux/pm_opp.h
-@@ -23,6 +23,7 @@ struct opp_table;
- 
- enum dev_pm_opp_event {
- 	OPP_EVENT_ADD, OPP_EVENT_REMOVE, OPP_EVENT_ENABLE, OPP_EVENT_DISABLE,
-+	OPP_EVENT_ADJUST_VOLTAGE,
- };
- 
- #if defined(CONFIG_PM_OPP)
-@@ -53,6 +54,9 @@ int dev_pm_opp_add(struct device *dev, u
- 		   unsigned long u_volt);
- void dev_pm_opp_remove(struct device *dev, unsigned long freq);
- 
-+int dev_pm_opp_adjust_voltage(struct device *dev, unsigned long freq,
-+			      unsigned long u_volt);
-+
- int dev_pm_opp_enable(struct device *dev, unsigned long freq);
- 
- int dev_pm_opp_disable(struct device *dev, unsigned long freq);
-@@ -139,6 +143,13 @@ static inline void dev_pm_opp_remove(str
- {
- }
- 
-+static inline int
-+dev_pm_opp_adjust_voltage(struct device *dev, unsigned long freq,
-+			  unsigned long u_volt)
-+{
-+	return 0;
-+}
-+
- static inline int dev_pm_opp_enable(struct device *dev, unsigned long freq)
- {
- 	return 0;
diff --git a/target/linux/ipq806x/patches-4.9/0050-OPP-Allow-notifiers-to-call-dev_pm_opp_get_-voltage-.patch b/target/linux/ipq806x/patches-4.9/0050-OPP-Allow-notifiers-to-call-dev_pm_opp_get_-voltage-.patch
deleted file mode 100644
index 7b41157fd6b..00000000000
--- a/target/linux/ipq806x/patches-4.9/0050-OPP-Allow-notifiers-to-call-dev_pm_opp_get_-voltage-.patch
+++ /dev/null
@@ -1,107 +0,0 @@
-From 4a17bbfcf72c94b37079e39a7c1e1e8653f7fe92 Mon Sep 17 00:00:00 2001
-From: Stephen Boyd <sboyd@codeaurora.org>
-Date: Fri, 18 Sep 2015 17:52:07 -0700
-Subject: [PATCH 50/69] OPP: Allow notifiers to call dev_pm_opp_get_{voltage,
- freq} RCU-free
-
-We pass the dev_pm_opp structure to OPP notifiers but the users
-of the notifier need to surround calls to dev_pm_opp_get_*() with
-RCU read locks to avoid lockdep warnings. The notifier is already
-called with the dev_opp's srcu lock held, so it should be safe to
-assume the devm_pm_opp structure is already protected inside the
-notifier. Update the lockdep check for this.
-
-Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
-Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
-Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
-Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
----
- drivers/base/power/opp/core.c | 19 ++++++++++---------
- 1 file changed, 10 insertions(+), 9 deletions(-)
-
---- a/drivers/base/power/opp/core.c
-+++ b/drivers/base/power/opp/core.c
-@@ -32,9 +32,10 @@ LIST_HEAD(opp_tables);
- /* Lock to allow exclusive modification to the device and opp lists */
- DEFINE_MUTEX(opp_table_lock);
- 
--#define opp_rcu_lockdep_assert()					\
-+#define opp_rcu_lockdep_assert(s)					\
- do {									\
- 	RCU_LOCKDEP_WARN(!rcu_read_lock_held() &&			\
-+			 !(s && srcu_read_lock_held(s)) &&		\
- 			 !lockdep_is_held(&opp_table_lock),		\
- 			 "Missing rcu_read_lock() or "			\
- 			 "opp_table_lock protection");			\
-@@ -72,7 +73,7 @@ struct opp_table *_find_opp_table(struct
- {
- 	struct opp_table *opp_table;
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	if (IS_ERR_OR_NULL(dev)) {
- 		pr_err("%s: Invalid parameters\n", __func__);
-@@ -106,7 +107,7 @@ unsigned long dev_pm_opp_get_voltage(str
- 	struct dev_pm_opp *tmp_opp;
- 	unsigned long v = 0;
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	tmp_opp = rcu_dereference(opp);
- 	if (IS_ERR_OR_NULL(tmp_opp))
-@@ -138,7 +139,7 @@ unsigned long dev_pm_opp_get_freq(struct
- 	struct dev_pm_opp *tmp_opp;
- 	unsigned long f = 0;
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	tmp_opp = rcu_dereference(opp);
- 	if (IS_ERR_OR_NULL(tmp_opp) || !tmp_opp->available)
-@@ -172,7 +173,7 @@ bool dev_pm_opp_is_turbo(struct dev_pm_o
- {
- 	struct dev_pm_opp *tmp_opp;
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	tmp_opp = rcu_dereference(opp);
- 	if (IS_ERR_OR_NULL(tmp_opp) || !tmp_opp->available) {
-@@ -300,7 +301,7 @@ struct dev_pm_opp *dev_pm_opp_get_suspen
- {
- 	struct opp_table *opp_table;
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	opp_table = _find_opp_table(dev);
- 	if (IS_ERR(opp_table) || !opp_table->suspend_opp ||
-@@ -380,7 +381,7 @@ struct dev_pm_opp *dev_pm_opp_find_freq_
- 	struct opp_table *opp_table;
- 	struct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	opp_table = _find_opp_table(dev);
- 	if (IS_ERR(opp_table)) {
-@@ -444,7 +445,7 @@ struct dev_pm_opp *dev_pm_opp_find_freq_
- {
- 	struct opp_table *opp_table;
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	if (!dev || !freq) {
- 		dev_err(dev, "%s: Invalid argument freq=%p\n", __func__, freq);
-@@ -486,7 +487,7 @@ struct dev_pm_opp *dev_pm_opp_find_freq_
- 	struct opp_table *opp_table;
- 	struct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);
- 
--	opp_rcu_lockdep_assert();
-+	opp_rcu_lockdep_assert(NULL);
- 
- 	if (!dev || !freq) {
- 		dev_err(dev, "%s: Invalid argument freq=%p\n", __func__, freq);
diff --git a/target/linux/ipq806x/patches-4.9/0051-PM-OPP-Add-a-helper-to-get-an-opp-regulator-for-devi.patch b/target/linux/ipq806x/patches-4.9/0051-PM-OPP-Add-a-helper-to-get-an-opp-regulator-for-devi.patch
deleted file mode 100644
index fc1a36efc08..00000000000
--- a/target/linux/ipq806x/patches-4.9/0051-PM-OPP-Add-a-helper-to-get-an-opp-regulator-for-devi.patch
+++ /dev/null
@@ -1,52 +0,0 @@
-From d06ca5e7a3cf726f5be5ffd96e93ccd798b8c09a Mon Sep 17 00:00:00 2001
-From: Georgi Djakov <georgi.djakov@linaro.org>
-Date: Thu, 12 May 2016 14:41:33 +0300
-Subject: [PATCH 51/69] PM / OPP: Add a helper to get an opp regulator for
- device
-
-Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
----
- drivers/base/power/opp/core.c | 21 +++++++++++++++++++++
- include/linux/pm_opp.h        |  1 +
- 2 files changed, 22 insertions(+)
-
---- a/drivers/base/power/opp/core.c
-+++ b/drivers/base/power/opp/core.c
-@@ -151,6 +151,27 @@ unsigned long dev_pm_opp_get_freq(struct
- }
- EXPORT_SYMBOL_GPL(dev_pm_opp_get_freq);
- 
-+struct regulator *dev_pm_opp_get_regulator(struct device *dev)
-+{
-+	struct opp_table *opp_table;
-+	struct regulator *reg;
-+
-+	rcu_read_lock();
-+
-+	opp_table = _find_opp_table(dev);
-+	if (IS_ERR(opp_table)) {
-+		rcu_read_unlock();
-+		return ERR_CAST(opp_table);
-+	}
-+
-+	reg = opp_table->regulator;
-+
-+	rcu_read_unlock();
-+
-+	return reg;
-+}
-+EXPORT_SYMBOL_GPL(dev_pm_opp_get_regulator);
-+
- /**
-  * dev_pm_opp_is_turbo() - Returns if opp is turbo OPP or not
-  * @opp: opp for which turbo mode is being verified
---- a/include/linux/pm_opp.h
-+++ b/include/linux/pm_opp.h
-@@ -31,6 +31,7 @@ enum dev_pm_opp_event {
- unsigned long dev_pm_opp_get_voltage(struct dev_pm_opp *opp);
- 
- unsigned long dev_pm_opp_get_freq(struct dev_pm_opp *opp);
-+struct regulator *dev_pm_opp_get_regulator(struct device *dev);
- 
- bool dev_pm_opp_is_turbo(struct dev_pm_opp *opp);
- 
diff --git a/target/linux/ipq806x/patches-4.9/0052-PM-OPP-Update-the-voltage-tolerance-when-adjusting-t.patch b/target/linux/ipq806x/patches-4.9/0052-PM-OPP-Update-the-voltage-tolerance-when-adjusting-t.patch
deleted file mode 100644
index 9065911d518..00000000000
--- a/target/linux/ipq806x/patches-4.9/0052-PM-OPP-Update-the-voltage-tolerance-when-adjusting-t.patch
+++ /dev/null
@@ -1,38 +0,0 @@
-From 4533c285c2aedce6d4434d7b877066de3b1ecb33 Mon Sep 17 00:00:00 2001
-From: Georgi Djakov <georgi.djakov@linaro.org>
-Date: Thu, 25 Aug 2016 18:43:35 +0300
-Subject: [PATCH 52/69] PM / OPP: Update the voltage tolerance when adjusting
- the OPP
-
-When the voltage is adjusted, the voltage tolerance is not updated.
-This can lead to situations where the voltage min value is greater
-than the voltage max value. The final result is triggering a BUG()
-in the regulator core.
-Fix this by updating the voltage tolerance values too.
-
-Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
----
- drivers/base/power/opp/core.c | 5 +++++
- 1 file changed, 5 insertions(+)
-
---- a/drivers/base/power/opp/core.c
-+++ b/drivers/base/power/opp/core.c
-@@ -1566,6 +1566,7 @@ int dev_pm_opp_adjust_voltage(struct dev
- 	struct opp_table *opp_table;
- 	struct dev_pm_opp *new_opp, *tmp_opp, *opp = ERR_PTR(-ENODEV);
- 	int r = 0;
-+	unsigned long tol;
- 
- 	/* keep the node allocated */
- 	new_opp = kmalloc(sizeof(*new_opp), GFP_KERNEL);
-@@ -1602,6 +1603,10 @@ int dev_pm_opp_adjust_voltage(struct dev
- 
- 	/* plug in new node */
- 	new_opp->u_volt = u_volt;
-+	tol = u_volt * opp_table->voltage_tolerance_v1 / 100;
-+	new_opp->u_volt = u_volt;
-+	new_opp->u_volt_min = u_volt - tol;
-+	new_opp->u_volt_max = u_volt + tol;
- 
- 	list_replace_rcu(&opp->node, &new_opp->node);
- 	mutex_unlock(&opp_table_lock);
diff --git a/target/linux/ipq806x/patches-4.9/0054-cpufreq-dt-Handle-OPP-voltage-adjust-events.patch b/target/linux/ipq806x/patches-4.9/0054-cpufreq-dt-Handle-OPP-voltage-adjust-events.patch
deleted file mode 100644
index 7cd6c6b5a10..00000000000
--- a/target/linux/ipq806x/patches-4.9/0054-cpufreq-dt-Handle-OPP-voltage-adjust-events.patch
+++ /dev/null
@@ -1,144 +0,0 @@
-From 10577f74c35bd395951d1b2382c8d821089b5745 Mon Sep 17 00:00:00 2001
-From: Stephen Boyd <sboyd@codeaurora.org>
-Date: Fri, 18 Sep 2015 17:52:08 -0700
-Subject: [PATCH 54/69] cpufreq-dt: Handle OPP voltage adjust events
-
-On some SoCs the Adaptive Voltage Scaling (AVS) technique is
-employed to optimize the operating voltage of a device. At a
-given frequency, the hardware monitors dynamic factors and either
-makes a suggestion for how much to adjust a voltage for the
-current frequency, or it automatically adjusts the voltage
-without software intervention.
-
-In the former case, an AVS driver will call
-dev_pm_opp_modify_voltage() and update the voltage for the
-particular OPP the CPUs are using. Add an OPP notifier to
-cpufreq-dt so that we can adjust the voltage of the CPU when AVS
-updates the OPP.
-
-Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
-Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
-Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
----
- drivers/cpufreq/cpufreq-dt.c | 68 ++++++++++++++++++++++++++++++++++++++++++--
- 1 file changed, 65 insertions(+), 3 deletions(-)
-
---- a/drivers/cpufreq/cpufreq-dt.c
-+++ b/drivers/cpufreq/cpufreq-dt.c
-@@ -32,6 +32,9 @@ struct private_data {
- 	struct device *cpu_dev;
- 	struct thermal_cooling_device *cdev;
- 	const char *reg_name;
-+	struct notifier_block opp_nb;
-+	struct mutex lock;
-+	unsigned long opp_freq;
- };
- 
- static struct freq_attr *cpufreq_dt_attr[] = {
-@@ -43,9 +46,16 @@ static struct freq_attr *cpufreq_dt_attr
- static int set_target(struct cpufreq_policy *policy, unsigned int index)
- {
- 	struct private_data *priv = policy->driver_data;
-+	int ret;
-+	unsigned long target_freq = policy->freq_table[index].frequency * 1000;
-+
-+	mutex_lock(&priv->lock);
-+	ret = dev_pm_opp_set_rate(priv->cpu_dev, target_freq);
-+	if (!ret)
-+		priv->opp_freq = target_freq;
-+	mutex_unlock(&priv->lock);
- 
--	return dev_pm_opp_set_rate(priv->cpu_dev,
--				   policy->freq_table[index].frequency * 1000);
-+	return ret;
- }
- 
- /*
-@@ -86,6 +96,39 @@ node_put:
- 	return name;
- }
- 
-+static int opp_notifier(struct notifier_block *nb, unsigned long event,
-+			void *data)
-+{
-+	struct dev_pm_opp *opp = data;
-+	struct private_data *priv = container_of(nb, struct private_data,
-+						 opp_nb);
-+	struct device *cpu_dev = priv->cpu_dev;
-+	struct regulator *cpu_reg;
-+	unsigned long volt, freq;
-+	int ret = 0;
-+
-+	if (event == OPP_EVENT_ADJUST_VOLTAGE) {
-+		cpu_reg = dev_pm_opp_get_regulator(cpu_dev);
-+		if (IS_ERR(cpu_reg)) {
-+			ret = PTR_ERR(cpu_reg);
-+			goto out;
-+		}
-+		volt = dev_pm_opp_get_voltage(opp);
-+		freq = dev_pm_opp_get_freq(opp);
-+
-+		mutex_lock(&priv->lock);
-+		if (freq == priv->opp_freq) {
-+			ret = regulator_set_voltage_triplet(cpu_reg, volt, volt, volt);
-+		}
-+		mutex_unlock(&priv->lock);
-+		if (ret)
-+			dev_err(cpu_dev, "failed to scale voltage: %d\n", ret);
-+	}
-+
-+out:
-+	return notifier_from_errno(ret);
-+}
-+
- static int resources_available(void)
- {
- 	struct device *cpu_dev;
-@@ -153,6 +196,7 @@ static int cpufreq_init(struct cpufreq_p
- 	bool fallback = false;
- 	const char *name;
- 	int ret;
-+	struct srcu_notifier_head *opp_srcu_head;
- 
- 	cpu_dev = get_cpu_device(policy->cpu);
- 	if (!cpu_dev) {
-@@ -242,13 +286,29 @@ static int cpufreq_init(struct cpufreq_p
- 		goto out_free_opp;
- 	}
- 
-+	mutex_init(&priv->lock);
-+
-+	rcu_read_lock();
-+	opp_srcu_head = dev_pm_opp_get_notifier(cpu_dev);
-+	if (IS_ERR(opp_srcu_head)) {
-+		ret = PTR_ERR(opp_srcu_head);
-+		rcu_read_unlock();
-+		goto out_free_priv;
-+	}
-+
-+	priv->opp_nb.notifier_call = opp_notifier;
-+	ret = srcu_notifier_chain_register(opp_srcu_head, &priv->opp_nb);
-+	rcu_read_unlock();
-+	if (ret)
-+		goto out_free_priv;
-+
- 	priv->reg_name = name;
- 	priv->opp_table = opp_table;
- 
- 	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);
- 	if (ret) {
- 		dev_err(cpu_dev, "failed to init cpufreq table: %d\n", ret);
--		goto out_free_priv;
-+		goto out_unregister_nb;
- 	}
- 
- 	priv->cpu_dev = cpu_dev;
-@@ -287,6 +347,8 @@ static int cpufreq_init(struct cpufreq_p
- 
- out_free_cpufreq_table:
- 	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);
-+out_unregister_nb:
-+	srcu_notifier_chain_unregister(opp_srcu_head, &priv->opp_nb);
- out_free_priv:
- 	kfree(priv);
- out_free_opp:
diff --git a/target/linux/ipq806x/patches-4.9/0055-cpufreq-dt-Add-L2-frequency-scaling-support.patch b/target/linux/ipq806x/patches-4.9/0055-cpufreq-dt-Add-L2-frequency-scaling-support.patch
deleted file mode 100644
index e0ae1f05826..00000000000
--- a/target/linux/ipq806x/patches-4.9/0055-cpufreq-dt-Add-L2-frequency-scaling-support.patch
+++ /dev/null
@@ -1,90 +0,0 @@
-From 0759cdff49f1cf361bf503c13f7bcb33da43ab95 Mon Sep 17 00:00:00 2001
-From: Georgi Djakov <georgi.djakov@linaro.org>
-Date: Tue, 8 Sep 2015 11:24:41 +0300
-Subject: [PATCH 55/69] cpufreq-dt: Add L2 frequency scaling support
-
-Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
----
- drivers/cpufreq/cpufreq-dt.c | 41 ++++++++++++++++++++++++++++++++++++++++-
- include/linux/cpufreq.h      |  2 ++
- 2 files changed, 42 insertions(+), 1 deletion(-)
-
---- a/drivers/cpufreq/cpufreq-dt.c
-+++ b/drivers/cpufreq/cpufreq-dt.c
-@@ -48,11 +48,41 @@ static int set_target(struct cpufreq_pol
- 	struct private_data *priv = policy->driver_data;
- 	int ret;
- 	unsigned long target_freq = policy->freq_table[index].frequency * 1000;
-+	struct clk *l2_clk = policy->l2_clk;
-+	unsigned int l2_freq;
-+	unsigned long new_l2_freq = 0;
- 
- 	mutex_lock(&priv->lock);
- 	ret = dev_pm_opp_set_rate(priv->cpu_dev, target_freq);
--	if (!ret)
-+
-+	if (!ret) {
-+		if (!IS_ERR(l2_clk) && policy->l2_rate[0] && policy->l2_rate[1] &&
-+				policy->l2_rate[2]) {
-+			static unsigned long krait_l2[CONFIG_NR_CPUS] = { };
-+			int cpu, ret = 0;
-+
-+			if (target_freq >= policy->l2_rate[2])
-+				new_l2_freq = policy->l2_rate[2];
-+			else if (target_freq >= policy->l2_rate[1])
-+				new_l2_freq = policy->l2_rate[1];
-+			else
-+				new_l2_freq = policy->l2_rate[0];
-+
-+			krait_l2[policy->cpu] = new_l2_freq;
-+			for_each_present_cpu(cpu)
-+				new_l2_freq = max(new_l2_freq, krait_l2[cpu]);
-+
-+			l2_freq = clk_get_rate(l2_clk);
-+
-+			if (l2_freq != new_l2_freq) {
-+				/* scale l2 with the core */
-+				ret = clk_set_rate(l2_clk, new_l2_freq);
-+			}
-+		}
-+
- 		priv->opp_freq = target_freq;
-+	}
-+
- 	mutex_unlock(&priv->lock);
- 
- 	return ret;
-@@ -197,6 +227,8 @@ static int cpufreq_init(struct cpufreq_p
- 	const char *name;
- 	int ret;
- 	struct srcu_notifier_head *opp_srcu_head;
-+	struct device_node *l2_np;
-+	struct clk *l2_clk = NULL;
- 
- 	cpu_dev = get_cpu_device(policy->cpu);
- 	if (!cpu_dev) {
-@@ -321,6 +353,13 @@ static int cpufreq_init(struct cpufreq_p
- 		policy->suspend_freq = dev_pm_opp_get_freq(suspend_opp) / 1000;
- 	rcu_read_unlock();
- 
-+	l2_clk = clk_get(cpu_dev, "l2");
-+	if (!IS_ERR(l2_clk))
-+		policy->l2_clk = l2_clk;
-+	l2_np = of_find_node_by_name(NULL, "qcom,l2");
-+	if (l2_np)
-+		of_property_read_u32_array(l2_np, "qcom,l2-rates", policy->l2_rate, 3);
-+
- 	ret = cpufreq_table_validate_and_show(policy, freq_table);
- 	if (ret) {
- 		dev_err(cpu_dev, "%s: invalid frequency table: %d\n", __func__,
---- a/include/linux/cpufreq.h
-+++ b/include/linux/cpufreq.h
-@@ -73,6 +73,8 @@ struct cpufreq_policy {
- 	unsigned int		cpu;    /* cpu managing this policy, must be online */
- 
- 	struct clk		*clk;
-+	struct clk		*l2_clk; /* L2 clock */
-+	unsigned int		l2_rate[3]; /* L2 bus clock rate thresholds */
- 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
- 
- 	unsigned int		min;    /* in kHz */
diff --git a/target/linux/ipq806x/patches-4.9/0056-cpufreq-dt-Add-missing-rcu-locks.patch b/target/linux/ipq806x/patches-4.9/0056-cpufreq-dt-Add-missing-rcu-locks.patch
deleted file mode 100644
index c0eb2eb3cd9..00000000000
--- a/target/linux/ipq806x/patches-4.9/0056-cpufreq-dt-Add-missing-rcu-locks.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-From 001a8dcb56ced58c518aaa10a4f0ba5e878705b6 Mon Sep 17 00:00:00 2001
-From: Georgi Djakov <georgi.djakov@linaro.org>
-Date: Tue, 17 May 2016 16:15:43 +0300
-Subject: [PATCH 56/69] cpufreq-dt: Add missing rcu locks
-
-Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
----
- drivers/cpufreq/cpufreq-dt.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/drivers/cpufreq/cpufreq-dt.c
-+++ b/drivers/cpufreq/cpufreq-dt.c
-@@ -143,8 +143,10 @@ static int opp_notifier(struct notifier_
- 			ret = PTR_ERR(cpu_reg);
- 			goto out;
- 		}
-+		rcu_read_lock();
- 		volt = dev_pm_opp_get_voltage(opp);
- 		freq = dev_pm_opp_get_freq(opp);
-+		rcu_read_unlock();
- 
- 		mutex_lock(&priv->lock);
- 		if (freq == priv->opp_freq) {
